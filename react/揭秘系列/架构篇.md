# render阶段

主要理解`Fiber`构建和`Fiber`树生成

`render`阶段开始于 `performSyncWorkOnRoot` 和 `performConcurrentWorkOnRoot` 的调用，这取决于本次更新是同步还是异步更新。

```js
// performSyncWorkOnRoot会调用该方法
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

// performConcurrentWorkOnRoot会调用该方法
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

`Fiber Reconciler`是从通过遍历来实现异步中断的递归，所以`performUnitOfWork`工作可以分为 **“递”**和 **“归”**

## “递”阶段

会从`rootFiber`节点往下做**深度优先遍历**。为每一个`Fiber节点`调用[`beginWork`](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058)方法，该方法会根据传入的`Fiber`节点，创建`子Fiber`节点，同时将这两个节点连接起来。

当遍历到叶子节点（没有子组件时），就会进入**归**阶段。

## “归”阶段

归阶段会调用[`completeWork`](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652)处理`Fiber节点`。

当某个`Fiber`节点执行完毕之后，如果其存在兄弟`Fiber节点`，（即`fiber.sibling !== null`），会进入其`兄弟Fiber`的“递”阶段。

“递和归”会交错执行，直到“归”到`rootFiber`。至此，`render`阶段工作结束。

下面有个例子：

```js
function App() {
  return (
    <div>
      i am
      <span>KaSong</span>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById("root"));
```

fiber树：

![fiber树](../imgs/fiber-render-demo.png)

`render阶段`执行过程

```sh
1. rootFiber beginWork
2. App Fiber beginWork
3. div Fiber beginWork
4. "i am" Fiber beginWork
5. "i am" Fiber completeWork
6. span Fiber beginWork
7. span Fiber completeWork
8. div Fiber completeWork
9. App Fiber completeWork
10. rootFiber completeWork
```

> 之所以没有"KaSong"节点的beginWork和completeWork，是因为对于单一文本子节点的fiber，react会进行性能优化

## `beginWork`

[源码](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3075)

**主要工作：** 传入当前`Fiber节点`，创建`子Fiber节点`

```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {
  // ...
}
```

- `current`：当前组件的`Fiber节点`对应的**上一次**更新的`Fiber节点`

- `workInProgress`：当前组件对应的`Fiber节点`

- `renderLanes`：更新优先级

组件更新分为 `mount` 和 `update` 两个阶段，在`mount`阶段，由于组件不存在上一次更新的`Fiber节点`，所以 `current === null`，

所以 `update`对应的`current !== null`

所以`beginWork`内部区分了 `mount`和`update`2个阶段的逻辑，这里有2个注意点：

- `update`时，会根据情况，复用`current`，即上一次更新的Fiber节点

- `mount`时，会根据`workInProgress.tag`创建不同的`子Fiber节点`


```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {

  // update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）
  if (current !== null) {
    // ...省略

    // 复用current
    return bailoutOnAlreadyFinishedWork(
      current,
      workInProgress,
      renderLanes,
    );
  } else {
    didReceiveUpdate = false;
  }

  // mount时：根据tag不同，创建不同的子Fiber节点
  switch (workInProgress.tag) {
    case IndeterminateComponent: 
      // ...省略
    case LazyComponent: 
      // ...省略
    case FunctionComponent: 
      // ...省略
    case ClassComponent: 
      // ...省略
    case HostRoot:
      // ...省略
    case HostComponent:
      // ...省略
    case HostText:
      // ...省略
    // ...省略其他类型
  }
}
```