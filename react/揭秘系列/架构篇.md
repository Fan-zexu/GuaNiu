# render阶段

主要理解`Fiber`构建和`Fiber`树生成

`render`阶段开始于 `performSyncWorkOnRoot` 和 `performConcurrentWorkOnRoot` 的调用，这取决于本次更新是同步还是异步更新。

```js
// performSyncWorkOnRoot会调用该方法
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

// performConcurrentWorkOnRoot会调用该方法
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

`Fiber Reconciler`是从通过遍历来实现异步中断的递归，所以`performUnitOfWork`工作可以分为 **“递”**和 **“归”**

## “递”阶段

会从`rootFiber`节点往下做**深度优先遍历**。为每一个`Fiber节点`调用[`beginWork`](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058)方法，该方法会根据传入的`Fiber`节点，创建`子Fiber`节点，同时将这两个节点连接起来。

当遍历到叶子节点（没有子组件时），就会进入**归**阶段。

## “归”阶段

归阶段会调用[`completeWork`](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652)处理`Fiber节点`。

当某个`Fiber`节点执行完毕之后，如果其存在兄弟`Fiber节点`，（即`fiber.sibling !== null`），会进入其`兄弟Fiber`的“递”阶段。

“递和归”会交错执行，直到“归”到`rootFiber`。至此，`render`阶段工作结束。

下面有个例子：

```js
function App() {
  return (
    <div>
      i am
      <span>KaSong</span>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById("root"));
```

fiber树：

![fiber树](../imgs/fiber-render-demo.png)

`render阶段`执行过程

```sh
1. rootFiber beginWork
2. App Fiber beginWork
3. div Fiber beginWork
4. "i am" Fiber beginWork
5. "i am" Fiber completeWork
6. span Fiber beginWork
7. span Fiber completeWork
8. div Fiber completeWork
9. App Fiber completeWork
10. rootFiber completeWork
```

> 之所以没有"KaSong"节点的beginWork和completeWork，是因为对于单一文本子节点的fiber，react会进行性能优化

## `beginWork`

[源码](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3075)

**主要工作：** 传入当前`Fiber节点`，创建`子Fiber节点`

```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {
  // ...
}
```

- `current`：当前组件的`Fiber节点`对应的**上一次**更新的`Fiber节点`

- `workInProgress`：当前组件对应的`Fiber节点`

- `renderLanes`：更新优先级

组件更新分为 `mount` 和 `update` 两个阶段，在`mount`阶段，由于组件不存在上一次更新的`Fiber节点`，所以 `current === null`，

所以 `update`对应的`current !== null`

所以`beginWork`内部区分了 `mount`和`update`2个阶段的逻辑，这里有2个注意点：

- `update`时，会根据情况，复用`current`，即上一次更新的Fiber节点

- `mount`时，会根据`workInProgress.tag`创建不同的`子Fiber节点`


```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {

  // update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）
  if (current !== null) {
    // ...省略

    // 复用current
    return bailoutOnAlreadyFinishedWork(
      current,
      workInProgress,
      renderLanes,
    );
  } else {
    didReceiveUpdate = false;
  }

  // mount时：根据tag不同，创建不同的子Fiber节点
  switch (workInProgress.tag) {
    case IndeterminateComponent: 
      // ...省略
    case LazyComponent: 
      // ...省略
    case FunctionComponent: 
      // ...省略
    case ClassComponent: 
      // ...省略
    case HostRoot:
      // ...省略
    case HostComponent:
      // ...省略
    case HostText:
      // ...省略
    // ...省略其他类型
  }
}
```

### update

看源码中，在`update`的判断下，满足以下情况，`didReceiveUpdate = false`，（即可以复用子Fiber节点，不需要新建）

- `oldProps === newProps && workInProgress.type === current.type`，即props与fiber.type不变

- `!includesSomeLane(renderLanes, updateLanes)`，即当前Fiber节点优先级不够

### mount

主要是根据 `workInProgress.tag`来创建不同类型的子Fiber节点

> [源码这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactWorkTags.js) 全部tag类型

### reconcileChildren

[源码](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L233)

它是`Reconciler`的核心：

- 对于`mount`，它会创建子Fiber节点

- 对于`update`，它会**对比**组件当前与上次更新的`Fiber节点`，生成新的`Fiber节点`。也就是 `Diff`算法

```js
export function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderLanes: Lanes
) {
  if (current === null) {
    // 对于mount的组件
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    // 对于update的组件
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
```

这里注意：

1. `mount`和`update`最后都会把生成的`fiber`赋值给`workInProgress.child`

2. `reconcileChildFibers`有点区别是，会给生成的`Fiber节点`打上`effectTag`属性。`mountChildFibers`则不会

### effectTag

`render阶段`是在内存中完成的，它工作结束会通知`Renderer`去渲染`DOM`，而要执行`DOM`操作的具体类型就保存在 `fiber.effectTag`中

> [这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js) 看`effectTag`对应的`DOM`

这里使用**二进制**来表示`effectTag`，方便位运算

举例，如果要通知`Renderer`将`Fiber节点`中对应的`DOM节点`插入到页面中，需要满足：

1. `fiber.stateNode`存在，即fiber中保存的`DOM节点`信息存在

2. `fiber.effectTag & Placement !== 0`，即`Fiber节点`存在“插入”的属性

### beginWork流程图

![流程图](../imgs/beginWork-flow.png)


## completeWork

[源码](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L673)

方法概览，重点关注`HostComponent`

```js
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      return null;
    case ClassComponent: {
      // ...省略
      return null;
    }
    case HostRoot: {
      // ...省略
      updateHostContainer(workInProgress);
      return null;
    }
    case HostComponent: {
      // ...省略
      return null;
    }
  // ...省略
```