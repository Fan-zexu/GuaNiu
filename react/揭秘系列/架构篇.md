# render阶段

主要理解`Fiber`构建和`Fiber`树生成

`render`阶段开始于 `performSyncWorkOnRoot` 和 `performConcurrentWorkOnRoot` 的调用，这取决于本次更新是同步还是异步更新。

```js
// performSyncWorkOnRoot会调用该方法
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

// performConcurrentWorkOnRoot会调用该方法
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

`Fiber Reconciler`是从通过遍历来实现异步中断的递归，所以`performUnitOfWork`工作可以分为 **“递”**和 **“归”**

## “递”阶段

会从`rootFiber`节点往下做**深度优先遍历**。为每一个`Fiber节点`调用[`beginWork`](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058)方法，该方法会根据传入的`Fiber`节点，创建`子Fiber`节点，同时将这两个节点连接起来。

当遍历到叶子节点（没有子组件时），就会进入**归**阶段。

## “归”阶段

归阶段会调用[`completeWork`](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652)处理`Fiber节点`。

当某个`Fiber`节点执行完毕之后，如果其存在兄弟`Fiber节点`，（即`fiber.sibling !== null`），会进入其`兄弟Fiber`的“递”阶段。

“递和归”会交错执行，直到“归”到`rootFiber`。至此，`render`阶段工作结束。

下面有个例子：

```js
function App() {
  return (
    <div>
      i am
      <span>KaSong</span>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById("root"));
```

fiber树：

![fiber树](../imgs/fiber-render-demo.png)

`render阶段`执行过程

```sh
1. rootFiber beginWork
2. App Fiber beginWork
3. div Fiber beginWork
4. "i am" Fiber beginWork
5. "i am" Fiber completeWork
6. span Fiber beginWork
7. span Fiber completeWork
8. div Fiber completeWork
9. App Fiber completeWork
10. rootFiber completeWork
```

> 之所以没有"KaSong"节点的beginWork和completeWork，是因为对于单一文本子节点的fiber，react会进行性能优化

## `beginWork`

[源码](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3075)