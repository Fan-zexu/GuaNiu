# 基本概念

## 时间复杂度

一个函数，用大`O`表示，`O(1)、O(n)、O(n^2)、O(logn)...`，用来描述算法运行时间

`O(1)`：代码运行1次，`const map = { k: v }; const v = map[k]; `

`O(n)`：代码运行n次，比如一次for循环

`O(n^2)`：代码运行n*n次，比如两层循环嵌套

`O(logn)`：求以2为底n的对数（即2的多少次方等于n），即代表运行多少次。举例：

```js
let i = 1
while (i < n) {
    console.log(i)
    i *= 2
}
```

下面代码每次i都会乘以2，所以运行次数就是以2为底n的对数

## 空间复杂度

也用大`O`表示。用来描述代码运行中临时占用的内存空间大小

`O(1)`：一个变量 `let i = 0; i += 1`

`O(n)`：用到n个变量，比如循环定义变量：

```js
var arr = [];
for(i=0; i<n; i++) {
    arr.push(i)
}
```

`O(n^2)`：矩阵概念，二维数据

```js
let matrix = [];
for(let i=0; i<n; i++) {
    matrix[i] = [];
    for(let j=0; j<n; j++) {
        matrix[i].push(i+j)
    }
}
```

# 数据结构

## 栈

**先进后出/后进先出**

`JS`没有栈`API`，可以通过数组`Array`模拟

```js
const stack = []

stack.push(1) // 入栈
stack.push(2) // 入栈

const item1 = stack.pop() // 出栈
```

### DEMO

#### 十进制转二进制

```js
// 遍历数字 如果大于0 就可以继续转换2进制
  while (N > 0) {
    // 将数字的余数入栈
    stack.push(N % 2);

    // 除以2
    N = N >> 1;
  }
```

核心点：

1）如果十进制数是`大N`，那么转换二进制位就是`a[0]*2^0 + a[1]*2^1 + ... + a[n]*2^n`，那么二进制就是 `a[0]~a[n]`

2）那么对`大N`进行一次**除以2取余**（即`N % 2`），就可以得到`a[0]`。之后二进制变成 `a[1]*2^0 + a[2]*2^1 + ... + a[n]*2^n-1`，以此类推继续对`大N`取余，就可以得到 `a[1]`。注：这里这样推导：如果两边准备同时除以2，那么左边 `X + 2 * (a[1]*2^0 + a[2]*2^1 + ... + a[n]*2^n-1)` 等于右边 `2 * (N/2) + 余数 `，一目了然，第一项X就是`a[0] = 余数` ~

3）当`N`第一次取余之后，得到二进制最后一位`a[0]`，之后再次取余前，需要将二进制向右移动一位，这里可以使用**位运算符 >> 1**，`N >> 1`。举例：

```
N == 10，二进制 == 1010

第一次取余后，得到a[0] == 0，

第二次取余时，要等到a[1]，也就是1，所以这里用 N >> 1 即 1010 => 101。第二次取余结果就是 a[1] == 1
```

细节实现：

[传送门](./example/stack.js)

#### 判断字符串的有效括号



## 队列

**先进先出**

模拟：

```js
const queue = [];

queue.push(1); // 进队 [1]
queue.push(2); // 进队 [1, 2]

queue.shift() // 出队 [1] / [2]
```