# [55](https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150)

思路：
1. 遍历数组，记录当前能到达的最远位置
2. 如果当前下标大于最远位置，则返回false
3. 当循环结束，返回true

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
    var reach = 0; var n = nums.length;

    for (var i = 0 ; i < n; i++) {
        if (i > reach) {
            return false;
        }

        reach = Math.max(i+nums[i], reach);
    }

    return true;
};
```

时间：O(n)
空间：O(1)

优化：

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
    var reach = 0; var n = nums.length;

    for (var i = 0 ; i < n; i++) {
        if (i > reach) {
            return false;
        }

        reach = Math.max(i+nums[i], reach);

        // 最远距离大于或等于最后一位，则提前返回true
        if (reach >= n - 1) return true;

    }

    return false;
};
```


# [45](https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150)

返回跳到最后一位，需要的最小跳跃次数

```
示例 1:

输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。


示例 2:

输入: nums = [2,3,0,1,4]
输出: 2
```

思路1：

1. 从最后一位开始，往前找能跳到这里的最大位置（如果存在多个，则根据贪心，找距离最远的，即索引最小的）

2. 之后再找倒数第二步能跳到这里的最大位置

3. 以此类推，直到找到第一个位置

4. 返回跳转次数