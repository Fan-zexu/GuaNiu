# 业界干活

## 关于Rust在构建工具领域的应用

[Bundler的设计取舍](https://github.com/orgs/web-infra-dev/discussions/4)

### webpack的使用

#### 构建性能优化

- 各种loader：`swc-loader` `esbuild-loader` `thread-loader` `cache-loader`

- [MFSU](https://umijs.org/docs/guides/mfsu) 一种基于`Module Federation`的打包方案，据说比vite还快。是由`UmiJS`提供

- `Persistent Cache` 持久化缓存 ，第一次听说，也是`webpack5`支持的能力

#### 缺点

- 黑盒

- 性能瓶颈 

如 `Persistent Cache` 依赖业务配置良好的 [build dependencies](https://webpack.js.org/configuration/cache/#cachebuilddependencies)

`esbuild-loader` 不支持 `es5` 的降级

`cache-loader` 忘记清理 `cache` 导致产物没更新。

#### 解决方案

社区流行的「双引擎」方案，即上层框架统一的配置和插件，底层的引擎可以在webpack和vite之间切换。虽然解决一部分问题，但也存在挑战：

- 插件跨引擎复用，`rollup`和`webpack`插件机制不同

- vite在大型项目中表现不理想，首屏模块多的情况下，会有大量请求带来巨大的性能开销

- Rollup 的产物优化能力较弱？缺少`Bundle Splitting`？导致无法做精细优化。所以有些业务是dev环境用vite，生产环境用webpack....

#### 提到关于rollup

优点：产物极其干净，Treesharking 友好

缺点：

- `CommonJS`的支持，rollup目前的架构，无法对CommonJS完全兼容 [rollup commonjs options](https://github.com/rollup/plugins/tree/master/packages/commonjs#options)，(可以补充一些更详细的文档)

- 羸弱的编译性能，本身和webapck类似，都是使用Js实现Bundler，所以性能差不多。但是rollup不支持`Persistent Cache`，所以2次冷启动比webpack更差。
其次不支持`HMR`，但在library库场景下需要watch，但watch性能一般
