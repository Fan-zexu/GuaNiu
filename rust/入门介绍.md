# Rust入门介绍

## 简史

作者：`Graydon Hoare`，就职于`Mozilla`

设计灵感：他所在公寓楼里一个坏掉的电梯。电梯操作系统的软件崩溃了，这时候`Hoare`意识到这类问题通常「源于程序如何使用内存的问题」。一般这些类型设备的软件是用C或C++编写的，但这些语言「需要大量的内存管理，可能导致系统崩溃的错误」。因此，Hoare着手研究如何创建一种「既紧凑又无内存错误的编程语言」。

发展历程：

2006年，`Rust`作为一个个人项目被启动

2009年，`Mozilla`开始赞助

2010年，首次公开。编译器源码迁移`rust`，称为`rustc`

2012年，发布第一个正式版rust编译器

2015年5月15日，正式发布`rust1.0`

2021年2月8日，`rust`得到 AWS、华为、Google、微软以及 Mozilla投资，并成立Rust基金会

2024年初，google向基金会捐款100万，用于改善rust和c++互操作性。


## 能干什么

### 技术无边界

一般来说，Rust 语言可以用于开发：

- 传统命令行程序 ：`Rust` 编译器可以直接生成目标可执行程序，不需要任何解释程序。

- Web 应用： `Rust` 可以被编译成 `WebAssembly，WebAssembly` 是一种 JavaScript 的高效替代品。

- 网络服务器：`Rust` 用极低的资源消耗做到安全高效，且具备很强的大规模并发处理能力，十分适合开发普通或极端的服务器程序。

- 嵌入式设备：`Rust` 同时具有JavaScript 一般的高效开发语法和 C 语言的执行效率，支持底层平台的开发。

![rust-can-do](./imgs/rust-can-do.png)

### 前端领域

#### `SWC`

基于 Rust 的前端构建工具，可以理解为 `Rust` 版本的 `Babel`，但是性能有 10 倍提升。目前被 `Next.js、Deno , Rspack`等使用

#### `Tauri`

`Tauri` 是目前最流行的 `Electron` 替代方案，通过使用 `Rust` 和 `Webview2` 成功解决了 `Electron` 的包体积大和内存占用高的问题。

`Atom` 团队也是看到了 `Tauri` 的成功，才决定基于 Rust 去做 `Zed` 编辑器。

#### `Rspack`

字节出品，基于 `Rust` 的高性能 `Web` 构建工具, 对标 `Webpack`, 兼容大部分`api`，2014年9月初正式发布1.0版本

#### `Napi-rs`

用 `Rust` 和 `N-API` 开发高性能 `Node.js` 扩展，可以替代之前用 `C++` 开发的 `Node.js` 扩展，许多基于 `Rust` 语言开发的前端应用都结合这个库进行使用。

#### `Parcel2`

零配置构建工具，特点是快速编译和不需要配置，和 `Vite、Webpack`等打包比起来更加简单，而且是基于 `Rust` 开发

#### `Rocket`

可以帮助开发人员轻松编写安全的Web应用程序, 对标 Expressjs，性能卓越


## 优势

### 高性能

一方面，是由于它是系统级别的编程语言，性能堪比`c/c++`，无`GC`、无`运行时`，同时天然支持并发和异步。

另一方面，是它的内存管理方式。一些语言，比如`Javascript`靠引用计数器形式的垃圾回收的管理方式。另一些语言，比如`C++`靠手动管理内存的方式。

`Rust`选择第三种，通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。通过这种内存管理机制，使得 `Rust` 有惊人的内存利用率。


### 内存安全

`Rust` 丰富的类型系统和所有权模型保证了内存安全，通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查，如果违反了任何这些规则，程序都不能编译。

### 线程安全

`Rust` 通过一整套基础设施和类型检查，强迫这些线程问题暴露在编译阶段，相比花费大量时间尝试重现运行时并发 bug 出现的特定情况，`Rust` 会拒绝编译不正确的代码并提供解释问题的错误信息。

## 不足

### 学习成本高

学习曲线很陡峭，主要归功于它严格的类型检测以及“所有权”的概念。借用一张极客时间中的图来说明难度

![rust-study](./imgs/rust-study-hard.png)

### 编译时间长

由于 Rust 的编译器进行了大量的静态检查和优化，编译时间可能相对较长，特别是对于大型项目

### 生态系统相对不太完善

相比其他编程语言，`Rust` 的生态系统相对较小，可能缺乏一些常见的库和工具

### 错误处理繁琐

`Rust` 采用了 `Result` 和 `Option` 等类型来处理错误和空值，这要求开发人员进行显式的错误处理，导致一些额外的编码工作量。

## 生态

对于前端来说，`Rust`是比较贴近前端生态的。

### rustup

是 `Rust` 的安装和版本管理工具。还包括管理一些核心工具如：`cargo（Rust版的npm）、clippy（Rust版的eslint）、rustfmt（Rust版的prettier）`。

类比`nvm`

### rustc

是 Rust 的编译器，用来将源代码和生产二进制代码，变成一个或可执行文件。

类比`webpack`等打包工具

### cargo

是 Rust 的构建工具和包管理器，它可以用来构建、测试、发布等

对比 `npm` 与 `cargo` 命令

![cargovsnpm](./imgs/cargo-npm.png)

## 核心概念

### 设计哲学

为了达成「高性能」、『足够安全』的目标，Rust遵循了三条设计原则：

- 内存安全

- 零成本抽象

- 实用性

### 内存安全

#### Rust如何保证内存安全？

首先是保证「类型安全」

> 类型安全是指类型系统可以保证程序的行为是意义明确、不出错的。像C/C++语言的类型系统就不是类型安全的，因为它们并没有对无意义。一个最简单的例子就是数组越界，在C/C++语言中并不对其做任何检查，导致发生了语言规范规定之外的行为，也就是未定义行为（Undefined Behavior）

Rust主要借鉴了`Haskell`语言的类型设计，同时结合自身”内存安全“的思想搞出了一套安全内存管理模型，通过类型系统表达出来，就保证了「内存安全」。

#### 什么是内存安全？

简单来说，就是不会出现内存访问错误

以下几种情况就会产生内存错误：

- 引用空指针

- 使用未初始化内存

- 释放后使用，也就是使用悬垂指针

- 缓冲区溢出，比如数组越界

- 非法释放已经释放过的指针或未分配的指针，也就是重复释放。

为了保证内存安全，Rust搞出了严格的内存安全模型：

- 所有权系统

- 借用和生命周期

所有权系统：每个被分配的内存都有一个独占其所有权的指针。只有当该指针被销毁时，其对应的内存才能随之被释放。

借用和生命周期：每个变量都有其生命周期，一旦超出生命周期，变量就会被自动释放。如果是借用，则可以通过标记生命周期参数供编译器检查的方式，防止出现悬垂指针，也就是释放后使用的情况。

### 零成本抽象

除了安全性，Rust还追求高效开发和性能。

要做到高效开发，就需要具备一定抽象能力。这里对比`Ruby`和`Rust`代码：

![ruby-vs-rust](./imgs/ruby-vs-rust.png)

可以看出两者的抽象程度已经接近自然语言。不过`ruby`的抽象代价是牺牲性能，它需要依靠运行时来解释这一层的抽象。

反观`Rust`在编译阶段就把它展开成底层代码，省去了运行时的性能开销。


### 实用性

编程语言的实用性，没有统一的说法，一般可以从3个方面评判：

- 实践性，首先必须能够应用于开发工业级产品，其次要易于学习和使用。

- 有益性，是指能够对业界产生积极的效果或影响。

- 稳定性，是指语言自身要稳定。在解决同一个问题时，不会因为使用者不同而出现随机的结果。

关于「实践性」，`Rust`具备开发工业级产品能力。

- 首先，通过引入强大类型系统和所有权系统，同时保证内存和并发安全，且不失性能。

- 其次，通过更细颗粒度的设计错误处理机制，保证程序的健壮。

- 再次，通过非常好用的包管理器`Cargo`保证开发者间的相互协作。

- 最后，通过详细的官方文档、好用的在线`playground`、社区稳定积极的贡献，保证易于学习和使用

关于「有益性和稳定性」

`Rust`的诞生为业界提供了除`C/C++`之外更好的选择。同时作为底层系统级语言，支持各个领域（web、嵌入式、操作系统、游戏、AI、区块链）使用。同时自1.0发布以来进入了稳定期，虽然还在不断地改进和发布新的特性，但是Rust的核心是不变的。

## 前端应用