# 用Result处理可恢复的错误

```rs
enum Result<T, E> {
    Ok(T),
    Err(E)
}
```

通过打开文件场景，来处理成功和失败情况

```rs
use std::fs::File;

fn main() {
    let file_result = File::open("hello.txt");
}

```

`File::open`成功下，T是成功返回值的类型`std::fs::File`，是一个文件句柄

错误下，返回值类型是 `std::io::Error`


使用`match`处理`Result`成员

```rs
use std::fs::File;

fn main() {
    let file_result = File::open("hello.txt");

    let file = match file_result {
        Ok(file) => file,
        Err(error) => panic!("problem opening the file: {:?}", error),
    };
}
```

# 匹配不同的错误

`File::open`失败原因也要做区分:

```rs
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let file_result = File::open("hello.txt");

    let file = match file_result {
        Ok(file) => file,
        // Err(error) => panic!("problem opening the file: {:?}", error),
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("problem opening the file: {:?}, other_error");
            }
        }
    };
}
```

`File.open`返回的`Err`成员中的类型`io::Error`，它是一个标准库中提供的结构体。

这个结构体有一个kind方法，返回`ErrorKind`类型是`io::ErrorKind`。

这个`io::ErrorKind`类型是标准库提供的一个枚举，它定义了io操作可能导致的不同错误类型。

其中`ErrorKind::NotFound`代表尝试打开一个不存在的文件

官网还介绍了一个简洁写法：（个人看不太明白）

```rs
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
```