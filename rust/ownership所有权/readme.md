# 什么是所有权

> [官网原文](https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html)

## 栈 stack 和 堆 heap

栈，是`后进先出`的结构。栈中的所有数据都必须占用已知和固定的大小。

在编译时，大小未知或可能变化的数据，要存储在堆上。

当向堆存储数据时，需要先请求一定大小的空间。这里内存分配器会在堆上找到一块一定大小的空间，并把它标记为已使用，同时返回表示该位置地址的指针pointer。这个过程叫做“在堆上分配内存”，简称“分配”。

有个形象的例子：去餐馆就坐吃饭，当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。

---

入栈比在堆上分配内存要快，原因：

1. 入栈不需要寻找空间并分配内存，其位置总是栈顶。

2. 堆除了分配内存之外，还要做一些记录工作为下次分配做准备。

---

栈上访问数据速度比堆上快。因为堆上必须通过指针来访问。

## 所有权规则

1. Rust中每一个值都有一个所有者(owner)

2. 值在任意时刻有且只有一个所有者

3. 当所有者（变量）离开作用域时，这个值将被丢弃

## 变量作用域 scope

rust的变量作用域和JS差不多，JS中使用`let`不存在作用域提升。所以这里s的有效范围是括号内。

```rs
{                      // s 在这里无效，它尚未声明
    let s = "hello";   // 从此处起，s 是有效的

    // 使用 s
}                      // 此作用域已结束，s 不再有效

```

## String类型

用于可变字符串。这个类型管理被分配到堆上的数据，所以可以处理编译时未知大小的文本。应用如下：

```rs
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() 在字符串后追加字面值

    println!("{}", s); // 将打印 `hello, world!`

```

使用另一个字符串类型：`String`。其中`::`双冒号表示运算符，允许将特定的`from`函数置于`String`类型的命名空间下

