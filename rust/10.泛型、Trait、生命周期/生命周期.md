# 生命周期确保引用有效

Rust中每个引用都有其**生命周期**，也就是引用保持有效的作用域

## 生命周期避免悬垂引用 dangling references

```rs
fn main() {
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```

编译报错：由于`r`在使用前，先离开了作用域，所以r失效了

## 借用检测器

之所以上面可以检测报错，是因为Rust的借用检测器，它比较作用域来确保所有借用都是有效的

官方demo

```rs
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
```

r的生命周期标识是`'a`，x的生命周期标识是`'b`，a范围大于b，所以编译报错

原因：被引用的对象比它自身引用存在的时间更短


看一个正确的无悬垂引用的例子

```rs
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```

r中的引用在x有效的时候也总是有效的

## 函数中的泛型生命周期

官方例子，对比字符串长短

```rs
fn main() {
    let s1 = String::from("abcd");
    let s2 = "xyz";
    
    let result = longest(s1.as_str(), s2);

    println!("The longest string is {}", result);
}

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

```

编译会出现有关生命周期的报错，

```sh
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error

```

提示中表明返回值需要一个泛型生命周期参数。因为Rust并不清楚返回值的引用到底指向`x`还是`y`

为了修复这个错误，需要增加泛型生命周期参数来定义引用间的关系以便借用检测器可以进行分析。

## 生命周期注解语法

生命周期注解不改变引用的生命周期的长短，它用来描述多个引用生命周期相互的关系

语法：生命周期参数名以撇号(')开头，其名称通常是全小写。生命周期注解位于`&`后面，有一个空格来分割引用类型与生命周期注解

```rs
&i32 // 引用
&'a i32 // 带有显式生命周期的引用
&'a mut i32 // 带有显式生命周期的可变引用
```


## 函数签名中的生命周期注解

在函数签名中使用生命周期注解，需要在函数名和参数列表间的尖括号中声明泛型生命周期参数，就像泛型类型一样。

```rs
fn longest<'a>(x: &'a str, y: &'a str) -> &'a {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

具体应用例子：

```rs
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);  // The longest string is long string is long
    }
}
```

`string2`在内部作用域中是有效的，`string1`直到外部作用域结束一直有效。

这表明：`result`引用的生命周期必须是两个参数中【较短】的那个。


下面一个异常编译的例子

```rs
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}

```

如下报错：

```sh
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --> src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {}", result);
  |                                          ------ borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error

```

`longest`函数的参数和返回值都使用了相同的生命周期参数`'a`，进而这告诉Rust：`longest`函数返回的引用的生命周期应该与传入参数的生命周期中较短那个保持一致。因此，借用检查器不允许代码通过编译，因为它可能存在无效的引用。