# 生命周期确保引用有效

Rust中每个引用都有其**生命周期**，也就是引用保持有效的作用域

## 生命周期避免悬垂引用 dangling references

```rs
fn main() {
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```

编译报错：由于`r`在使用前，先离开了作用域，所以r失效了

## 借用检测器

之所以上面可以检测报错，是因为Rust的借用检测器，它比较作用域来确保所有借用都是有效的

官方demo

```rs
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
```

r的生命周期标识是`'a`，x的生命周期标识是`'b`，a范围大于b，所以编译报错

原因：被引用的对象比它自身引用存在的时间更短


看一个正确的无悬垂引用的例子

```rs
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```

r中的引用在x有效的时候也总是有效的